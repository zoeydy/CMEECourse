Starting code feedback for Zongyi, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.83 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: week2, week3, .git, week1, Feedback

Found the following files in parent directory: README.md, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp

*/sandbox/*
*.docx
*.jpeg

#LaTex/pdflatex auxiliary files:
*.aux
*.lof
*.log
*.lot
*.lb
*.cb
*.cb2
*.fmt
*.fot
*.toc
*.out
*.fls 

# BibTex/BibLaTex auxiliary files:
*.bbl 
*.bcf 
*.big
*.blx.aux 
*.blx.bib 
*.run.xml

# Python
__pycache__/

*~ 
*.tmp
#--------------------R gitignore template-------------------
# History files
.Rhistory
.Rapp.history
# Session Data files
.RData
# User-specific files
.Ruserdata
# Example code in package build process
*-Ex.R
# Output files from R CMD build
/*.tar.gz
# Output files from R CMD check
/*.Rcheck/
# RStudio files
.Rproj.user/
# produced vignettes
vignettes/*.html
vignettes/*.pdf
# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
.httr-oauth
# knitr and R markdown default cache directories
*_cache/
/cache/
# Temporary files created by R markdown
*.utf8.md
*.knit.md
# R Environment Variables
.Renviron
# pkgdown site
docs/
# translation temp files
po/*~

#------------------Python gitignore template-------------------------
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class
# C extensions
*.so
# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec
# Installer logs
pip-log.txt
pip-delete-this-directory.txt
# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
# Translations
*.mo
*.pot
# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
# Flask stuff:
instance/
.webassets-cache
# Scrapy stuff:
.scrapy
# Sphinx documentation
docs/_build/
# PyBuilder
.pybuilder/
target/
# Jupyter Notebook
.ipynb_checkpoints
# IPython
profile_default/
ipython_config.py
# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version
# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock
# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/
# Celery stuff
celerybeat-schedule
celerybeat.pid
# SageMath parsed files
*.sage.py
# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
# Spyder project settings
.spyderproject
.spyproject
# Rope project settings
.ropeproject
# mkdocs documentation
/site
# mypy
.mypy_cache/
.dmypy.json
dmypy.json
# Pyre type checker
.pyre/
# pytype static type analyzer
.pytype/
# Cython debug symbols
cython_debug/
#-------------------------------C gitignore template-----------------------------------------
# Prerequisites
*.d
# Object files
*.o
*.ko
*.obj
*.elf
# Linker output
*.ilk
*.map
*.exp
# Precompiled Headers
*.gch
*.pch
# Libraries
*.lib
*.a
*.la
*.lo
# Shared objects (inc. Windows DLLs)
*.dll
*.so
*.so.*
*.dylib
# Executables
*.exe
*.out
*.app
*.i*86
*.x86_64
*.hex
# Debug files
*.dSYM/
*.su
*.idb
*.pdb
# Kernel Module Compile Results
*.mod*
*.cmd
.tmp_versions/
modules.order
Module.symvers
Mkfile.old
dkms.conf
.DS_Store
*.save
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
My CMEE Coursework Repository
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: week1, week2, week3

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: data, code, sandbox, results

Found the following files: README.md, .gitignore

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# Week2-Python
## Install python
## Python varialble
## Python operator
## Python datastructure
## Using loop and range funciton
## Input and output
## Runing Python script
## Control flow tools
## Comprehension
## variable scope
## Writing Python programe
## Debuge
**********************************************************************

Found following files in results directory: fasta_result.txt...

Ideally, Results directory should be empty other than, perhaps a .gitkeep. 

 0.5 pts deducted per results file 

Current Points = 99.5

Found 21 code files: tuple.py, boilerplate.py, basic_io2.py, oaks.py, cfexercises2.py, basic_io1.py, oaks_debugme.py, loops.py, dictionary.py, lc2.py, basic_io3.py, control_flow.py, cfexercises1.py, test_control_flow.py, basic_csv.py, debugme.py, align_seqs.py, sysargv.py, scope.py, lc1.py, using_name.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file tuple.py...

File contents are:

**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

""" Birds is a tuple of tuples of length three: latin name, common name, mass.
    write a (short) script to print these on a separate line or output block by species 
    Hints: use the "print" command! You can use list comprehensions!"""

# latin = print(*{n[0] for n in birds}, sep="\n")
# common = print(*{n[1] for n in birds}, sep="\n")
# mass = print(*{n[2] for n in birds}, sep="\n")

for i in birds:
    print('latin:', i[0])
    print('common:', i[1])
    print('mass:', i[2])
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
latin: Passerculus sandwichensis
common: Savannah sparrow
mass: 18.7
latin: Delichon urbica
common: House martin
mass: 19
latin: Junco phaeonotus
common: Yellow-eyed junco
mass: 19.5
latin: Junco hyemalis
common: Dark-eyed junco
mass: 19.6
latin: Tachycineata bicolor
common: Tree swallow
mass: 20.2

**********************************************************************

Code ran without errors

Time consumed = 0.07826s

======================================================================
Inspecting script file boilerplate.py...

File contents are:

**********************************************************************
#~!/usr/bin/env python3

"""
    a python program formate
    """

__appname__ = '[boilerplate]'
__author__ = 'Zongyi (zh2720@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'License for this program/code'

## imports ##
import sys # module to interface out program with the operating system

## constants ##


"""functions""" 
def main(argv):
    """
    main entry point of the program
    """
    print("This is a boilerplate") # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__":
    """
    Makes sure the "main" function is called from command line
    """
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.08579s

======================================================================
Inspecting script file basic_io2.py...

File contents are:

**********************************************************************
"""
write a txt file -- File output
"""


#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()
**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.09084s

======================================================================
Inspecting script file oaks.py...

File contents are:

**********************************************************************
""" Finds just those taxa that are oak trees from a list of species"""

taxa = [
    'Quercus robur',
    'Fraxinus excelsior',
    'Pinus sylvestris',
    'Quercus cerris',
    'Quercus petraea',
]

def is_an_oak(name):
    return name.lower().startswith('quercus')

""" Using for loops"""
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

""" Using list comprehensions"""
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

""" Get names in upper case using for loops"""
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

""" Get names in upper case using list comprehensions"""
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
{'Quercus petraea', 'Quercus cerris', 'Quercus robur'}
{'Quercus petraea', 'Quercus cerris', 'Quercus robur'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}

**********************************************************************

Code ran without errors

Time consumed = 0.09343s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:

**********************************************************************
"""
Some loop example
"""

for j in range(12):
    if j % 3 == 0:
        print('Hello')
    
for j in range(15):
    if j % 5 == 3:
        print('Hello')
    elif j % 4 == 3:
        print('Hello')

z = 0 
while z != 15:
    print('Hello')
    z += 3

z = 12
while z < 100:
    if z == 31:
        for k in range(7):
            print('Hello')
    elif z == 18:
        print('Hello')
    z += 1
**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello

**********************************************************************

Code ran without errors

Time consumed = 0.07604s

======================================================================
Inspecting script file basic_io1.py...

File contents are:

**********************************************************************
"""
delete blank lines -- file
"""

##############
# FILE INPUT
##############
# Open a file for reading
f = open('../data/test.txt','r')
# use "implicit " for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../data/test.txt','r')
for line in f:
    if len(line.strip()) > 0:
        print(line)
f.close()
**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.07316s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:

**********************************************************************
import csv
import sys
import doctest

"""function to verdict if it is a oak"""
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus' 
    
    >>> is_an_oak("quercs")
    False

    >>> is_an_oak("quercuss")
    False

    >>> is_an_oak("quercus")
    False

    >>> is_an_oak("Quercus")
    True

    """
    return name == 'Quercus'

"""main funciton"""
def main(argv): 
    f = open('../data/TestOaksData.csv','r')
    g = open('../data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    # oaks = set()
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    f.close()
    g.close()
    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod() 
**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
['Genus', ' species']
The genus is: 
Genus

['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.14356s

======================================================================
Inspecting script file loops.py...

File contents are:

**********************************************************************
""" FOR Loops in python"""

for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]    
for k in my_list:
    print(k)

total = 0 
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

""" WHILE Loops in Python"""

z = 0
while z < 100:
    z = z + 1
    print(z)

b = True
while b:
    print("GERONIMO! infinite loops! ctrl+c to stop!")
    b = False

""" ctrl+c to stop!"""
**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

Found too many docstrings.  Check your script.

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loops! ctrl+c to stop!

**********************************************************************

Code ran without errors

Time consumed = 0.07725s

======================================================================
Inspecting script file dictionary.py...

File contents are:

**********************************************************************
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

"""Write a short python script to populate a dictionary called taxa_dic 
derived from  taxa so that it maps order names to sets of taxa. 
E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. """

taxa_dic = dict()
for tax in taxa:
        if tax[1] not in taxa_dic.keys():
                taxa_dic[tax[1]] = set([tax[0]])
        else:
                taxa_dic[tax[1]].add(tax[0])

print(taxa_dic)
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
{'Chiroptera': {'Myotis lucifugus'}, 'Rodentia': {'Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus'}, 'Afrosoricida': {'Microgale dobsoni', 'Microgale talazaci'}, 'Carnivora': {'Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus'}}

**********************************************************************

Code ran without errors

Time consumed = 0.07908s

======================================================================
Inspecting script file lc2.py...

File contents are:

**********************************************************************
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )


""" (1) Use a list comprehension to create a list of month,rainfall tuples where
        the amount of rain was greater than 100 mm."""
 
new_1 = [n for n in rainfall if n[1] > 100]
print(new_1)

"""(2) Use a list comprehension to create a list of just month names where the
        amount of rain was less than 50 mm. """

new_2 = [n[0] for n in rainfall if n[1] < 50]
print(new_2)

""" (3) Now do (1) and (2) using conventional loops (you can choose to do 
     this before 1 and 2 !). """

## (1)

new1 = ([])
for n in rainfall:
    if n[1] > 100:
        new1.append(n)
print(new1)

## (2)

new2 =([])
for n in rainfall:
    if n[1] < 50:
        new2.append(n[0])
print(new2)

**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

Found too many docstrings.  Check your script.

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']

**********************************************************************

Code ran without errors

Time consumed = 0.07863s

======================================================================
Inspecting script file basic_io3.py...

File contents are:

**********************************************************************
"""
Write a binary file -- Storing objects
"""

############
# Storing Objects
############
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../sandbox/testp.p', 'wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open ('../sandbox/testp.p', 'rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)
**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
{'a key': 10, 'another key': 11}

**********************************************************************

Code ran without errors

Time consumed = 0.10107s

======================================================================
Inspecting script file control_flow.py...

File contents are:

**********************************************************************
#~!/usr/bin/env python3

"""
    Some functions exemplifying the use of control statements
    """
#docstrings are considered part of the running code (normal comments are stripped). Hence, you can access your docstrings at run time.

__appname__ = 'contro_flow'
__author__ = 'Zongyi Hu (zh2720@ic.ac.uk)'
__version__ = '0.0.1'

import sys

"""is a number even or odd"""
def even_or_odd(x = 0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return "%d is Odd!" % x

"""
    Find which is the largest divisor of x among 2,3,4,5
    """
def largest_divisor_five(x = 120):
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0:#means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: #When all other(if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a var
    return "The largest divisor of %d is %d" % (x,largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2,x): # "range" returns a sequence of integers
        if x % i == 0:
            print("%d is not a prime: %d is a divisor" % (x,i))
            return False
    print("%d is a prime!" % x)
    return True

def find_all_primes(x=22):
    """Find all the prims up to x"""
    allprimes = []
    for i in range(2,x+1):
        if is_prime(i):
            allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes),x))
    return allprimes

"""main function"""
def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if __name__ == "__main__":
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
22 is Odd!
None
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is not a p
**********************************************************************

Code ran without errors

Time consumed = 0.08584s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:

**********************************************************************
#~!/usr/bin/env python3

"""Some functions doing arithmatic."""

__appname__ = 'cfexercises1'
__author__ = 'Zongyi Hu (zh2720@ic.ac.uk)'
__version__ = '0.0.1'

import sys

"""function sqrt"""
def foo_1(x = 1):
    return x ** 0.5
foo_1(3)
foo_1(9)
foo_1(49)

"""function compare two numbers"""
def foo_2(x=1, y=1):
    if x > y:
        return x
    return y
foo_2(2,3)
foo_2(3,2)

"""bubble sort"""
def foo_3(x=1, y=1, z=1):
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return [x, y, z]
foo_3(1, 3, 2)

"""factorial"""
def foo_4(x=1):
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result

"""factorial"""
def foo_5(x=1):# a recursive function that calculaes the facrotial of x
    if x == 1:
        return 1
    return x * foo_5(x - 1)

"""factorial"""
def foo_6(x=1): # Calculate the factorial of x in a different way
    facto = 1
    while x >= 1:
        facto = facto * x 
        x = x - 1
        return facto
    
"""main function"""
def main(argv):
    print(foo_1())
    print(foo_2())
    print(foo_3())
    print(foo_4())
    print(foo_5())
    print(foo_6())
    return(0)

if __name__ == "__main__":
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
1.0
1
[1, 1, 1]
1
1
1

**********************************************************************

Code ran without errors

Time consumed = 0.08735s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""

__author__ = 'Your Name (Your.Name@your.email.address)'
__version__ = '0.0.1'

import sys
import doctest # Import the doctest module

def even_or_odd(x=0):
    """Find whether a number x is even or odd.
      
    >>> even_or_odd(10)
    '10 is Even!'
    
    >>> even_or_odd(5)
    '5 is Odd!'
    
    whenever a float is provided, then the closest integer is used:    
    >>> even_or_odd(3.2)
    '3 is Odd!'
    
    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'
    
    """
    
    """Define function to be tested"""
    if x % 2 == 0:
        return "%d is Even!" % x
    return "%d is Odd!" % x

"""main function"""
def main(argv): 
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()   # To run with embedded tests
**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
22 is Even!
33 is Odd!

**********************************************************************

Code ran without errors

Time consumed = 0.15473s

======================================================================
Inspecting script file basic_csv.py...

File contents are:

**********************************************************************
"""
Extracting some rows from a file and save as a new file.
"""

import csv
 
# Read a file containing:
# 'Species','Infraorder','Family','Distribution'.'Body mass male (Kg)'
f = open('../data/testcsv.csv','r')

csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is", row[0])

f.close()

# write a file containing only species name and Body mass
f = open('../data/testcsv.csv','r')
g = open('../data/bodymass.csv','w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0],row[4]])

f.close()
g.close()
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.08943s

======================================================================
Inspecting script file debugme.py...

File contents are:

**********************************************************************
"""function to buggy"""
"""calculation "x-1/x"""
def buggyfunc(x):
    y = x
    for i in range(x):
        y = y-1
        z = x/y
    return z

buggyfunc(20)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "debugme.py", line 10, in <module>
    buggyfunc(20)
  File "debugme.py", line 7, in buggyfunc
    z = x/y
ZeroDivisionError: division by zero

======================================================================
Inspecting script file align_seqs.py...

File contents are:

**********************************************************************
#~!/usr/bin/env python3

"""save the best alignment along with the sequence's corresponding score. """

__appname__ = 'align_seqs'
__author__ = 'Zongyi Hu (zh2720@ic.ac.uk)'
__version__ = '0.0.1'

import sys

"""Two example sequences to match"""
# seq2 = "ATCGCCGGATTACGGG"
# seq1 = "CAATTCGGAT"

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

def longer_seq(seq1, seq2):
    global l1
    global l2
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        global s1
        global s2
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths

"""A function that computes a score by returning the number of matches starting from arbitrary startpoint (chosen by user)"""
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

"""now try to find the best match (highest score) for the two sequences"""
def best_match(s1, s2, l1, l2):
    my_best_align = None
    my_best_score = -1
    for i in range(l1):
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2 
            my_best_score = z 
    print(my_best_align)
    print(s1)
    print("Best score:", my_best_score)
    #store a best alignment in a .txt file
    g = open("../results/fasta_result.txt","w")
    g.write("The best align is:" + "\n")
    g.write(my_best_align + "\n")
    g.write(s1)
    g.write(f"The best score is: {my_best_score}" + "\n")
    g.close()

"""main function"""
def main(argv):
    with open("../data/sequence.csv") as f:
        seq1 = f.readline()
        seq2 = f.readline()
    longer_seq(seq1, seq2)
    best_match(s1, s2, l1, l2)
    return 0


if __name__ == "__main__": 
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG

5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG

2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG

1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG

1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG

1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG

2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG

4
 
.......-*-*-***--
.......CAATTCGGAT
ATCGCCGGATTACGGG

5
 
........------**-
........CAATTCGGAT
ATCGCCGGATTACGGG

2
 
.........--*---*-
.........CAATTCG
**********************************************************************

Code ran without errors

Time consumed = 0.08232s

======================================================================
Inspecting script file sysargv.py...

File contents are:

**********************************************************************
"""using sys"""
#!/usr/bin/env python3

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: ", str(sys.argv))
**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.08752s

======================================================================
Inspecting script file scope.py...

File contents are:

**********************************************************************
_a_global = 10 # a global variable

if _a_global >= 5:
    _b_global = _a_global + 5 # also a global variable

"""learning global and local variable"""
def a_function():
    _a_global = 5 # a local variable

    if _a_global >= 5:
        _b_global = _a_global + 5 # also a local variable

    _a_local = 4

    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value of _b_global is", _b_global)
    print("Inside the function, the value of _a_local is", _a_local)

    return None
a_function()

print("Outside of the function, the value of _a_global is", _a_global)
print("Outside of the function, the value of _b_global is", _b_global)


_a_global = 10

""" the difference of inside or outside the funtion"""
def b_function():
    _a_local = 4

    print("Inside the function, the value _a_local is", _a_local)
    print("Inside the function, the value of _a_global is", _a_global)

    return None
a_function()

print("Outside the function, the value of _a_global is", _a_global)


""" using global keyword to ssign a global variable from inside a function"""
_a_global = 10

print("Outside the function, the value of _a_global is", _a_global)

def c_function():
    global _a_global
    _a_global = 5
    _a_local = 4

    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value of _a_local is", _a_local)

    return None
a_function()

print("Outside the function, the value of _a_global now is",_a_global)


""" global keyword works inside the nested functions"""
"""function in function"""
def d_function():
    _a_global = 10

    def _a_function2():
        global _a_global
        _a_global = 20

    print("Before calling a_function, value of _a_global is", _a_global)

    _a_function2

    print("After calling _a_function2, value of _a_global is", _a_global)

    return None
a_function()

print("The value of a_global in main workspace / namespace is", _a_global)


_a_global = 10

"""befor or after calling the function"""
"""function in function"""
def e_function():
    def _a_function2():
        global _a_global
        _a_global = 20

    print("Before calling a_function, value of _a_global is", _a_global)

    _a_function2()

    print("After calling _a_function2, value of _a_global is", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is", _a_global)

"""learn to use subfunction"""
**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
Inside the function, the value of _a_global is 5
Inside the function, the value of _b_global is 10
Inside the function, the value of _a_local is 4
Outside of the function, the value of _a_global is 10
Outside of the function, the value of _b_global is 15
Inside the function, the value of _a_global is 5
Inside the function, the value of _b_global is 10
Inside the function, the value of _a_local is 4
Outside the function, the value of _a_global is 10
Outside the function, the value of _a_global is 
**********************************************************************

Code ran without errors

Time consumed = 0.09071s

======================================================================
Inspecting script file lc1.py...

File contents are:

**********************************************************************
"""print objects in one sectory seperately"""

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

"""Write three separate list comprehensions that create three different
        lists containing the latin names, common names and mean body masses for
        each species in birds, respectively. """

latin = [species[0] for species in birds]
common = [species[1] for species in birds]
masses = [species[2] for species in birds]
print(latin)
print(common)
print(masses)

"""(2) Now do the same using conventional loops (you can choose to do this 
       before 1 !)."""

latin = []
common = []
masses = []
for species in birds:
        latin.append(species[0])
        common.append(species[1])
        masses.append(species[2])
print(latin)
print(common)
print(masses)
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

Found too many docstrings.  Check your script.

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.08359s

======================================================================
Inspecting script file using_name.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""using_name"""

__author__ = 'Zongyi Hu (zh2720@ic.ac.uk)'
__version__ = '0.0.1'

if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')

print("This module's name is: " + __name__)
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
This program is being run by itself
This module's name is: __main__

**********************************************************************

Code ran without errors

Time consumed = 0.08457s

======================================================================
======================================================================
Finished running scripts

Ran into 1 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!