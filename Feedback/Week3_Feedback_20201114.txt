Starting code feedback for Zongyi, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 4.10 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: MiniProject, week2, week3, .git, week1, week4, week6, Feedback, week5

Found the following files in parent directory: README.md, csv, sc, .gitignore, pd

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp

*/sandbox/*
*.docx
*.jpeg

week4/

#LaTex/pdflatex auxiliary files:
*.aux
*.lof
*.log
*.lot
*.lb
*.cb
*.cb2
*.fmt
*.fot
*.toc
*.out
*.fls 

# BibTex/BibLaTex auxiliary files:
*.bbl 
*.bcf 
*.big
*.blx.aux 
*.blx.bib 
*.run.xml

# Python
__pycache__/

*~ 
*.tmp
#--------------------R gitignore template-------------------
# History files
.Rhistory
.Rapp.history
# Session Data files
.RData
# User-specific files
.Ruserdata
# Example code in package build process
*-Ex.R
# Output files from R CMD build
/*.tar.gz
# Output files from R CMD check
/*.Rcheck/
# RStudio files
.Rproj.user/
# produced vignettes
vignettes/*.html
vignettes/*.pdf
# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
.httr-oauth
# knitr and R markdown default cache directories
*_cache/
/cache/
# Temporary files created by R markdown
*.utf8.md
*.knit.md
# R Environment Variables
.Renviron
# pkgdown site
docs/
# translation temp files
po/*~

#------------------Python gitignore template-------------------------
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class
# C extensions
*.so
# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec
# Installer logs
pip-log.txt
pip-delete-this-directory.txt
# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
# Translations
*.mo
*.pot
# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal
# Flask stuff:
instance/
.webassets-cache
# Scrapy stuff:
.scrapy
# Sphinx documentation
docs/_build/
# PyBuilder
.pybuilder/
target/
# Jupyter Notebook
.ipynb_checkpoints
# IPython
profile_default/
ipython_config.py
# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version
# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock
# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/
# Celery stuff
celerybeat-schedule
celerybeat.pid
# SageMath parsed files
*.sage.py
# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
# Spyder project settings
.spyderproject
.spyproject
# Rope project settings
.ropeproject
# mkdocs documentation
/site
# mypy
.mypy_cache/
.dmypy.json
dmypy.json
# Pyre type checker
.pyre/
# pytype static type analyzer
.pytype/
# Cython debug symbols
cython_debug/
#-------------------------------C gitignore template-----------------------------------------
# Prerequisites
*.d
# Object files
*.o
*.ko
*.obj
*.elf
# Linker output
*.ilk
*.map
*.exp
# Precompiled Headers
*.gch
*.pch
# Libraries
*.lib
*.a
*.la
*.lo
# Shared objects (inc. Windows DLLs)
*.dll
*.so
*.so.*
*.dylib
# Executables
*.exe
*.out
*.app
*.i*86
*.x86_64
*.hex
# Debug files
*.dSYM/
*.su
*.idb
*.pdb
# Kernel Module Compile Results
*.mod*
*.cmd
.tmp_versions/
modules.order
Module.symvers
Mkfile.old
dkms.conf
.DS_Store
*.save
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
My CMEE Coursework Repository
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 6 weekly directories: week1, week2, week3, week4, week5, week6

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: data, code, sandbox, results

Found the following files: README.md, .gitignore

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# Week 3 -- Computing, Data management and visualization in R

## Brief description

1. The foundations of using R for scientific computing in biology by exploiting it full potential as a fully featured object-oriented programming language.
2. The key princepals and methods in R for data processing, storage, exploration and visualization

## Requirements
Need to ```install.package(tydiverse)``` when running DataWrangTidy.R
Need to ```install.packages("reshape2")``` when running DataWrang.R
Need to ```install.packages('sqldf')``` when running SQLinR.R

## Language

R

## Author name and contact

Zongyi Hu zh2720@ic.ac.uk
**********************************************************************

Found following files in results directory: MyData.csv,  SizeRatio_Subplots.pdf, MyLinReg.pdf, cor_list.png,  Prey_Subplots.pdf, PP_Results.csv,  Pred_Subplots.pdf, Girko.pdf, PP_Regress_Results.csv, PP_Regress.pdf, TreeHts.csv...

Ideally, Results directory should be empty other than, perhaps a .gitkeep. 

 0.5 pts deducted per results file 

Current Points = 94.5

Found 27 code files: TreeHeight.R, browse.R, preallocate.R, plotLin.R, PP_Dists.R, TAutoCorr.tex, try.R, Vectorize2.R, TAutoCorr.R, boilerplate.R, apply1.R, PP_Regress.R, MyBars.R, DataWrang.R, control_flow.R, Vectorize1.R, SQLinR.R, sample.R, apply2.R, Ricker.R, break.R, next.R, R_conditionals.R, Girko.R, GPDD_Data.R, basic_io.R, DataWrangTidy.R

Found the following extra files: Test.sqlite
0.5 pt deducted per extra file

Current Points = 94.0

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
# This function calculates heights of trees given distance of each tree
# form its base and angle to its top, using the trigonometric formula
# 
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees: The angle of elevation of tree
# distance: The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

trees_data <- read.csv("../data/trees.csv", header = TRUE)

TreeHeight <- function(degrees,distance){
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    print(paste('Tree height is', height))

    return(height)
}

TreeHeight(37, 40)

trees_data$Tree.Height.m = TreeHeight(trees_data$Angle.degrees,trees_data$Distance.m)
write.csv(trees_data, "../results/TreeHts.csv", row.names = F)

**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Tree height is 30.1421620041118"
[1] 30.14216
  [1] "Tree height is 27.8021161438536" "Tree height is 45.2460250644405"
  [3] "Tree height is 14.6654828109493" "Tree height is 14.9341751666304"
  [5] "Tree height is 35.9703591412599" "Tree height is 32.4102133664874"
  [7] "Tree height is 17.4582436344144" "Tree height is 30.1373803987097"
  [9] "Tree height is 20.3124778877177" "Tree height is 24.4316633466933"
 [11] "Tree height is 27.5021323376702" "Tree height is 25.1559006982628"
 [13] 
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.19471s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
Exponential <- function(N0 = 1, r = 1, generations = 10){
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations){
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type="l", main="Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.24979s

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
rm(list = ls())


NoPreallocFun <- function(x){
    a <- vector() # empty vector
    for (i in 1:x) {
        a <- c(a, i)
        # print(a)
        print(object.size(a))
    }
}

system.time(NoPreallocFun(10))

PreallocFun <- function(x){
    a <- rep(NA, x) # pre-allocated vector
    for (i in 1:x) {
        a[i] <- i
        # print(a)
        print(object.size(a))
    }
}

system.time(PreallocFun(10))
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
56 bytes
56 bytes
64 bytes
64 bytes
80 bytes
80 bytes
80 bytes
80 bytes
96 bytes
96 bytes
   user  system elapsed 
   0.02    0.00    0.02 
96 bytes
96 bytes
96 bytes
96 bytes
96 bytes
96 bytes
96 bytes
96 bytes
96 bytes
96 bytes
   user  system elapsed 
  0.006   0.000   0.006 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.22884s

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
rm(list = ls())

require(ggplot2)
##### Mathematical display
####### Let’s try mathematical annotation on a axis, and in the plot area.
####### First create some linear regression “data”:

x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))
p
# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
p
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

p

pdf("../results/MyLinReg.pdf")
p
graphics.off()

**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2

======================================================================
Inspecting script file PP_Dists.R...

File contents are:

**********************************************************************
rm(list = ls())
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
MyDF_New <- data.frame(Prey.mass = log(MyDF$Prey.mass), 
                       Predator.mass = log(MyDF$Predator.mass), 
                       SizeRatio = log(MyDF$Prey.mass/MyDF$Predator.mass),
                       Feeding.type = MyDF$Type.of.feeding.interaction,
                       stringsAsFactors = F)

####### plotting
FileName <- c("Pred_Subplots.pdf", "Prey_Subplots.pdf", "SizeRatio_Subplots.pdf")
DataType <- c("Predator.mass", "Prey.mass", "SizeRatio")
FeedingType <- unique(MyDF_New$Feeding.type)


for (a in 1: length(DataType)){
  pdf(paste("../results/",FileName[a]), 11.7, 8.3)
  par(mfcol = c(1,5))
  for(i in FeedingType) {
    #browser()
    Subset <- subset(MyDF_New, Feeding.type == i)
    temp <- Subset[,names(Subset)== DataType[a]]
    plot(density(temp), xlab=i, ylab="Density", main="")
    # density(temp$a)
    # boxplot(log(Subset$a) ~ Subset$Feeding.type, 
    #         xlab = i,
    #         ylab = a,)
    mtext(paste(DataType[a]," by feeding interaction type"), side=3, outer=TRUE, line=-3)
  }
  graphics.off()
}


####### calculation

MeanDF <- data.frame()
MedianDF <- data.frame()

for (i in 1:length(FeedingType)) {
  # browser()
  Subset <- subset(MyDF_New, Feeding.type == FeedingType[i])
  MeanDF <- rbind(MeanDF, t(data.frame(apply(Subset[,-ncol(MyDF_New)], 2, mean))))
  MedianDF <- rbind(MedianDF, t(data.frame(apply(Subset[,-ncol(MyDF_New)], 2, median))))
}

# Set dataframe names
row.names(MeanDF) <- FeedingType
row.names(MedianDF) <- FeedingType
names(MeanDF) <- paste(DataType, "Mean")
names(MedianDF) <- paste(DataType, "Median")


OutputDF <- rbind(t(MeanDF), t(MedianDF))
write.csv(OutputDF ,"../results/PP_Results.csv")








# MeanOutput <- list(NA * 5)
# MedianOutput <- list(NA * 5)
# for (i in 1:length(FeedingType)){
#   Subset <- subset(MyDF_New, Feeding.type == FeedingType[i])
#   MeanOutput[[i]] <- apply(Subset[,-ncol(MyDF_New)], 2, mean)
#   MedianOutput[[i]] <- apply(Subset[,-ncol(MyDF_New)], 2, median)
# }
# MeanOutput
# MedianOutput
**********************************************************************

Testing PP_Dists.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.50151s

======================================================================
Inspecting script file TAutoCorr.tex...

File contents are:

**********************************************************************
\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Auto-correlation in weather}
\author{zongyi Hu}
\date{October 2020}

\usepackage{natbib}
\usepackage{graphicx}

\begin{document}

\maketitle

\section{Introduction}
This is a document states how you can use R to auto-correlate the data.

\section{Process}

1. Using cor() function in R to calculate the correlation coefficient between successive years and store it. 

2. Repeat the correlation coefficient calculation 10000 times by randomly permuting the time series, and then recalculating the correlation coefficient for each randomly permuted year sequence and storing it. The graph will be showed at the end of the PDF.

3. Then calculate what fraction of the correlation coefficients from the previous step were greater than that from step 1 (this is the approximate p-value).

\begin{figure}[h!]

\centering
\includegraphics[scale= 0.7]{../results/cor_list.png}
\caption{1000 times calculate correlation coefficient}
\label{fig:universe}

\end{figure}



\section{Conclusion}
The calculated p-value is 3e-04, less than 0.5 shows that the temperature between successive years are independent.



\end{document}

**********************************************************************

Testing TAutoCorr.tex...

Output (only first 500 characters): 


**********************************************************************
This is pdfTeX, Version 3.14159265-2.6-1.40.20 (TeX Live 2019/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(./TAutoCorr.tex
LaTeX2e <2020-02-02> patch level 2
L3 programming layer <2020-02-14>
(/usr/share/texlive/texmf-dist/tex/latex/base/article.cls
Document Class: article 2019/12/20 v1.4l Standard LaTeX document class
(/usr/share/texlive/texmf-dist/tex/latex/base/size10.clo))
(/usr/share/texlive/texmf-dist/tex/latex/base/inputenc.sty)
(/usr/share/texl
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.85473s

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
doit <- function(x){
  temp_x <- sample(x, replace = TRUE)
  if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
    print(paste("Mean of this sample was:", as.character(mean(temp_x))))
  } 
  else {
    stop("Couldn't calculate mean: too few unique values!")
  }
}

# Now generate your population
popn <- rnorm(50)
hist(popn)

# use lapply like you did before
lapply(1:15, function(i) doit(popn))
# use try
result <- lapply(1:15, function(i) try(doit(popn), FALSE))
class(result)
result
result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
  result[[i]] <- try(doit(popn), FALSE)
}
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.0360832811256178"
[1] "Mean of this sample was: 0.017895341219484"
[1] "Mean of this sample was: -0.18416063621785"
[1] "Mean of this sample was: -0.28830465640119"

**********************************************************************

Encountered error or warning:
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Calls: lapply -> FUN -> doit
Execution halted

======================================================================
Inspecting script file Vectorize2.R...

File contents are:

**********************************************************************
# Runs the stochastic Ricker equation with gaussian fluctuations

rm(list=ls())

stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
  for (pop in 1:length(p0)){#loop through the populations
    
    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr,pop] <- N[yr-1,pop] * exp(r * (1 - N[yr - 1,pop] / K) + rnorm(1,0,sigma))
    
    }
  }
 return(N)

}
stochrick()

# Now write another function called stochrickvect that vectorizes the above 
# to the extent possible, with improved performance: 


stochrickvect1 <-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
    
    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr,] <- N[yr-1,] * exp(r * (1 - N[yr - 1,] / K) + rnorm(1,0,sigma))
    
    }
 return(N)

}

stochrickvect1()

stochrickvect2 <-function(p0=runif(100,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,1000)
  N[,1]<-p0
  
    
    for (pop in 2:1000){ 

      N[,pop] <- N[,pop-1] * exp(r * (1 - N[,pop-1] / K) + rnorm(1,0,sigma))
    
    }
 return(N)

}
stochrickvect2()

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrick()))

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect1()))

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect2()))

**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 


**********************************************************************
            [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
  [1,] 0.7232138 0.5403334 1.2170156 1.3268725 0.5963833 0.8618249 1.4183191
  [2,] 0.7511491 0.6834791 0.8247229 0.8449631 0.7619709 0.9217768 0.8874651
  [3,] 0.9984666 0.7868144 1.0425392 0.8628404 0.8777244 0.7737322 1.1013232
  [4,] 0.8097258 0.4418197 1.2719090 1.0774181 0.8653197 1.1384298 0.8517943
  [5,] 1.3615939 1.0282922 0.9725866 1.0994764 1.0290193 0.9447254 1.0980692
  [6,] 0.8938267 0.9822286 1.0658473 1.
**********************************************************************

Code ran without errors or warnings

Time consumed = 1.39466s

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:

**********************************************************************
rm(list = ls())
load("../data/KeyWestAnnualMeanTemperature.RData")

ats2 <- data.frame(Temp1 = ats$Temp[1:length(ats$Temp)-1], Temp2 = ats$Temp[2:length(ats$Temp)])
cor0 <- cor(ats2$Temp1, ats2$Temp2)
# nrow(ats)
# length(ats$Temp)

cor_list <- vector()
for(i in 1:10000){
  shuffle <- data.frame(shuffle1 = sample(ats2$Temp1, length(ats2$Temp1), replace = FALSE), 
                        shuffle2 = sample(ats2$Temp2, length(ats2$Temp2), replace = FALSE))
  cor_list <- c(cor_list, cor(shuffle$shuffle1, shuffle$shuffle2))
}

biger_num <- subset(cor_list, cor_list > cor0)

p <- length(biger_num)/10000

# plot(1:10000, cor_list)

# save the graph in jpg
png(file="../results/cor_list.png",
    width=600, height=350)
hist(cor_list)
dev.off()
hist(cor_list)
**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 


**********************************************************************
null device 
          1 

**********************************************************************

Code ran without errors or warnings

Time consumed = 3.27551s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
rm(list = ls())

# A boilerplate R script

MyFunction <- function(Arg1,Arg2){
    print(paste('Argument', as.character(Arg1), 'is', class(Arg1)))
    print(paste('Argument', as.character(Arg2), 'is', class(Arg2)))

    return(c(Arg1,Arg2)) # this is optional, but very useful
}

MyFunction(1,2)
MyFunction('hello', 'world')
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is numeric"
[1] "Argument 2 is numeric"
[1] 1 2
[1] "Argument hello is character"
[1] "Argument world is character"
[1] "hello" "world"

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.17710s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
rm(list = ls())
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1] -0.15242810  0.15572742 -0.30849868  0.65790137  0.18532767 -0.08830877
 [7]  0.04155752  0.35084971  0.20800540 -0.01118360
 [1] 0.8229632 1.6595819 1.0508715 2.0437283 1.4426663 0.5380803 1.3139814
 [8] 0.7114350 0.2966761 0.5171226
 [1]  0.16538058  0.20191911 -0.31753752  0.30805351  0.40086072 -0.10851847
 [7] -0.07861691 -0.37671551  0.43094025  0.41318417

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.16090s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:

**********************************************************************
# plotting
rm(list = ls())
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
require(ggplot2)


pdf("../results/PP_Regress.pdf")


  p <- ggplot(MyDF, aes(x = log(Prey.mass), y = log(Predator.mass), 
                        colour = Predator.lifestage)) +
    geom_point(shape = 3) +
    labs(x = "Prey mass in grams", y = "Predator mass in grams") +
    geom_smooth(method='lm', fullrange = TRUE) +
    facet_grid(Type.of.feeding.interaction ~. , scales = "free") +
    theme(legend.position = "bottom") +
    guides(col = guide_legend(nrow=1))

  print(p)

graphics.off()

# calculation
FeedingType <- unique(MyDF$Type.of.feeding.interaction)
DF <- data.frame(FeedingType = NULL,
                 LifeStage = NULL,
                 Slope = NULL,
                 Intercept = NULL,
                 R2 = NULL,
                 f.value = NULL,
                 P.value = NULL,
                 stringsAsFactors=FALSE) 

for(a in 1:length(FeedingType)){
  Subset1 <- subset(MyDF, Type.of.feeding.interaction == FeedingType[a])
  LifeStage <- unique(Subset1$Predator.lifestage)
  for (b in 1:length(LifeStage)){
    # browser()
    Subset2 <- subset(Subset1, Predator.lifestage == LifeStage[b])
    Model <- lm(log(Predator.mass)~log(Prey.mass), data = Subset2)
    Output <- summary(Model)
    if(is.null(Output$fstatistic[1])){
      DF2 <- data.frame(FeedingType = FeedingType[a],
                       LifeStage = LifeStage[b],
                       Slope = NA,
                       Intercept = NA,
                       R2 = NA,
                       f.value = NA,
                       P.value = NA,
                       stringsAsFactors=FALSE) 
    } else{
      DF2 <- data.frame(FeedingType = FeedingType[a], LifeStage = LifeStage[b],
                        Slope = Output$coefficients[2,1], Intercept = Output$coefficients[1,1], 
                        R2 = Output$r.squared, f.value = Output$fstatistic[1], P.value = Output$coefficients[8])
    }
    DF <- rbind(DF,DF2)
  }
}

write.csv(DF, "../results/PP_Regress_Results.csv", row.names=FALSE)

**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2
`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************

####################  Annotating plots
rm(list = ls())


### In this example, we will use the ggplot geom text to annotate a plot.
a <- read.table("../data/Results.txt", header = TRUE)

a$ymin <- rep(0, dim(a)[1]) # append a column of zeros



# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y1,
  size = (0.5)
),
colour = "#E69F00",
alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y2,
  size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y3,
  size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
  scale_y_continuous("My y axis") + 
  theme_bw() + 
  theme(legend.position = "none") 
p


pdf("../results/MyBars.pdf")
p
graphics.off()
 
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Error in ggplot(a) : could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

rm(list = ls())

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) # t():exchange columns and rows
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

# check if the first row is column name in R
colnames(MyData)
# so manually delete the first row when transferring MyData into dataframe
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
# MyData is a matrix, TempData trun it into a frame without the first row, for later assign it as column name
colnames(TempData) <- MyData[1,] # assign column names from original data
# row names are not really bothering us, but we can get rid of it by:
rownames(TempData) <- NULL
head(TempData)

############# Convert from wide to long format  ###############
# install.packages("reshape2")
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
# id = c("data", "...save columns...", variable.name = "" # melt data's name, value.name = "" # the name of variable's value)

# change data type of each column
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############
# tidyverse
# !!!!!!!!!!!!!!!!!!!!!!!!!
# install.packages(c("tidyverse"))
# sudo apt install r-cran-tidyverse
require(tidyverse)
# list the package to if there are some name-conflict-masking messages
tidyverse_packages(include_self = TRUE) # the include_self = TRUE means list "tidyverse" as well 


**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error or warning:
Loading required package: reshape2
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.2     ✔ purrr   0.3.4
✔ tibble  3.0.3     ✔ dplyr   1.0.1
✔ tidyr   1.1.1     ✔ stringr 1.4.0
✔ readr   1.3.1     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
rm(list = ls())

# if statements
a <- TRUE

if (a == TRUE){
    print("a is TRUE")
}else{
    print("a is FALSE")
}

z <- runif(1)
if(z <= 0.5){
    print("z is less than a half")
}

# for loops
for(i in seq(10)){
    j <- i*i
    print(paste(i, "square is", j))
}

for(species in c('Heliodoxa rubinoides', 'Boissonneaua jardini', 'Sula nebouxii')){
    print(paste('The species is', species))
}

v1 <- c('a', 'bc', 'def')
for(i in v1){
    print(i)
}

# while loops
i <- 0
while(i<10){
    i <- i+1
    print(i^2)
}
**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "1 square is 1"
[1] "2 square is 4"
[1] "3 square is 9"
[1] "4 square is 16"
[1] "5 square is 25"
[1] "6 square is 36"
[1] "7 square is 49"
[1] "8 square is 64"
[1] "9 square is 81"
[1] "10 square is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.22556s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
rm(list = ls())

M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M){
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]){
    for (j in 1:Dimensions[2]){
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}
 
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.079   0.000   0.078 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.001   0.000   0.002 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.32244s

======================================================================
Inspecting script file SQLinR.R...

File contents are:

**********************************************************************
#install the sqlite package
#install.packages('sqldf')

# To load the packages
library(sqldf)

# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')

# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
            "CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)")

# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data

 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")


# Once we have our table, we can query the results using:

dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")


# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.

Resource <- read.csv("../data/Resource.csv")  # Read csv files into R

# Import data frames into database
 dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)

# Check that the data have been correctly imported into the School table.
 dbListTables(db)                 # The tables in the database
 dbListFields(db,"Resource")       # The columns in a table
 dbReadTable(db, "Resource")    # The data in a table

# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
 dbDisconnect(db)            # Close connection
 rm(list = c("Resource"))   # Remove data frames


**********************************************************************

Testing SQLinR.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Error: table Consumer already exists
Execution halted

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
######### Functions ##########
rm(list = ls())

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n){
    pop_sample <- sample(popn, n, replace = FALSE)
    return(mean(pop_sample))
}

## Calculate means using a for loop without preallocation:
loopy_sample1 <- function(popn, n, num){
    result1 <- vector() #Initialize empty vector of size 1 
    for(i in 1:num){
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## To run "num" iterations of the experiment using a for loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num){
    result2 <- vector(,num) #Preallocate expected size
    for(i in 1:num){
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

## To run "num" iterations of the experiment using a for loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num){
    result3 <- vector("list", num) #Preallocate expected size
    for(i in 1:num){
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}


## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num){
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## To run "num" iterations of the experiment using vectorization with lapply:
sapply_sample <- function(popn, n, num){
    result5 <- sapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}

popn <- rnorm(1000) # Generate the population
hist(popn)

n <- 20 # sample size for each experiment
num <- 1000 # Number of times to rerun the experiment

print("The loopy, non-preallocation approach takes:" )
print(system.time(loopy_sample1(popn, n, num)))

print("The loopy, but with preallocation approach takes:" )
print(system.time(loopy_sample2(popn, n, num)))

print("The loopy, non-preallocation approach on a list takes:" )
print(system.time(loopy_sample3(popn, n, num)))

print("The vectorized sapply approach takes:" )
print(system.time(sapply_sample(popn, n, num)))

print("The vectorized lapply approach takes:" )
print(system.time(lapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "The loopy, non-preallocation approach takes:"
   user  system elapsed 
  0.033   0.004   0.037 
[1] "The loopy, but with preallocation approach takes:"
   user  system elapsed 
  0.017   0.000   0.016 
[1] "The loopy, non-preallocation approach on a list takes:"
   user  system elapsed 
  0.014   0.000   0.013 
[1] "The vectorized sapply approach takes:"
   user  system elapsed 
  0.011   0.000   0.011 
[1] "The vectorized lapply approach takes:"
   user  system elapsed 
  0.010   0.000   0.
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.40771s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
rm(list = ls())

SomeOperation <- function(v){ # The function SomeOperation takes as input v which is the colomn of the later input matrix. Then if the sum of the numbers in each column are greater than zero, it multiplies that value by 100. So if v has positive and negative numbers, and the sum comes out to be positive, only then does it multiply all the values in v by 100 and return them.
    if(sum(v) > 0){ #note that sum(v) is a single (scalar) value
        return(v * 100)
    }
    return(v)
}

M <- matrix(rnorm(100), 10, 10)
print(apply(M, 1, SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
             [,1]        [,2]      [,3]        [,4]        [,5]          [,6]
 [1,]   -7.949781 -0.45918936  86.41184   -2.364009  0.17392013 -0.7484304188
 [2,]   22.851864 -0.32888850  81.87834   23.256130  0.10349995 -1.4343677788
 [3,]   68.414827 -0.63610142 -88.18747  -11.514994  0.06611786 -0.8788250149
 [4,]  -86.927928 -1.69635288  24.39597   12.767921 -0.03948633  2.6446595341
 [5,]  145.302490 -3.08805316  54.29432  -40.841862  0.36862954 -1.5024367252
 [6,]  140.102936 -0.02627649  33
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.18801s

======================================================================
Inspecting script file Ricker.R...

File contents are:

**********************************************************************
rm(list = ls())
Ricker <- function(N0=1, r=1, K=10, generations=50)
{
  # Runs a simulation of the Ricker model
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations)
  {
    N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
  }
  return (N)
}

plot(Ricker(generations=10), type="l")
**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.23149s

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
rm(list = ls())

i <- 0
while(i<Inf){
    if(i == 10){
        break #break out of the while loop
    }
    else{
        cat("i equals", i, '\n')
        i <- i+1
    }
}
**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals 0 
i equals 1 
i equals 2 
i equals 3 
i equals 4 
i equals 5 
i equals 6 
i equals 7 
i equals 8 
i equals 9 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.17603s

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
rm(list = ls())

for (i in 1:10){
    if((i %% 2 ) == 0)
    
        next # pass to next iteration of loop
    print(i)
}

# pay attention to the positon of print order
# for (i in 1:10){
#     if((i %% 2 ) == 0)
#     print(i)
#         next # pass to next iteration of loop
    
# }
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.26541s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
rm(list = ls())

# Checks if an integer is even

is.even <- function(n = 2){
    if(n %% 2 == 0){
        return(paste(n, 'is even.'))
    }
    return(paste(n, 'is odd.'))
}

is.even(6)


# Checks if a number is a power of 2

is.power2 <- function(n = 2){
    if(log2(n) %% 1 == 0){
        return(paste(n,'is the power of 2.'))
    }
    return(paste(n, 'is not the power of 2.'))
}

is.power2(4)


# Checks if a number is prime

is.prime <- function(n){
    if(n == 0){
        return(paste(n, 'is a zero.'))
    }
    if(n == 1){
        return(paste(n,"is just a unit."))
    }
    int <- 2:(n-1)
    if(all(n %% int != 0)){
        return(paste(n,'is a prime.'))
    }
    return(paste(n,'is not a prime.'))
}

is.prime(3)
**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even."
[1] "4 is the power of 2."
[1] "3 is a prime."

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.16788s

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
rm(list = ls())

## Plotting two dataframes together with Girko’s circular law
##### First, we need to build a function object that will calculate the ellipse (the perdicted bounds of the eigenvalues):
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns

###### now let's plot and save it in a PDF file

pdf("../results/Girko.pdf")
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p

graphics.off()

**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Error in ggplot(eigDF, aes(x = Real, y = Imaginary)) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file GPDD_Data.R...

File contents are:

**********************************************************************
# install.packages("maps")

rm(list = ls())
require(maps)
load("../data/GPDDFiltered.RData")

map(database = "world")
points(gpdd$long, gpdd$lat, pch=20, cex = .5, col = "red")

## The bias is that the points are all concentrated in Europe and North America,
## so the result we get from this data set may be hard to generalize
**********************************************************************

Testing GPDD_Data.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: maps

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
rm(list = ls())

# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names

**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
####################### Using tidyverse ########################
################################################################

rm(list = ls())

# install.packages(c("tidyverse"))
# sudo apt install r-cran-tidyverse
# install.packages("tidyr")

# require the packages we will use
require(tidyverse)
require(tidyr)

# list the package to if there are some name-conflict-masking messages
tidyverse_packages(include_self = TRUE) # the include_self = TRUE means list "tidyverse" as well 


############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv",header = F)) 
# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv",header = T, 
                       sep=";", stringsAsFactors = F)



############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)


############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) # t():exchange columns and rows
head(MyData)
dim(MyData)


############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0


############# Convert raw matrix to data frame ###############
# check if the first row is column name in R
colnames(MyData)
# so manually delete the first row when transferring MyData into dataframe
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
# MyData is a matrix, TempData trun it into a frame without the first row, for later assign it as column name
colnames(TempData) <- MyData[1,] # assign column names from original data
# row names are not really bothering us, but we can get rid of it by:
rownames(TempData) <- NULL
head(TempData)


############# Convert from wide to long format  ###############
MyWrangledData <-
  TempData %>%
  gather(Species, Count, -Cultivation,-Block,-Plot,-Quadrat)


# change data type of each column
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 


**********************************************************************
 [1] "broom"      "cli"        "crayon"     "dbplyr"     "dplyr"     
 [6] "forcats"    "ggplot2"    "haven"      "hms"        "httr"      
[11] "jsonlite"   "lubridate"  "magrittr"   "modelr"     "pillar"    
[16] "purrr"      "readr"      "readxl"     "reprex"     "rlang"     
[21] "rstudioapi" "rvest"      "stringr"    "tibble"     "tidyr"     
[26] "xml2"       "tidyverse" 
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "oct
**********************************************************************

Encountered error or warning:
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.2     ✔ purrr   0.3.4
✔ tibble  3.0.3     ✔ dplyr   1.0.1
✔ tidyr   1.1.1     ✔ stringr 1.4.0
✔ readr   1.3.1     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
======================================================================
Finished running scripts

Ran into 10 errors or warnings

Total time used: 45.39s 

======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 94.0

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!